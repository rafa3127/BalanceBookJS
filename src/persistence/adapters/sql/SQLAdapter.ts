import knex, { Knex } from 'knex';
import { IAdapter, IQueryFilters } from '../../interfaces.js';
import { SQLConfig } from './config.js';

export class SQLAdapter implements IAdapter {
    private db: Knex;

    constructor(config: SQLConfig) {
        this.db = knex(config);
    }

    async get<T = any>(collection: string, id: string): Promise<T | null> {
        const result = await this.db(collection).where('id', id).first();
        return result || null;
    }

    async save(collection: string, id: string | null, data: any): Promise<string> {
        const cleanData = this.sanitizeData(data);

        if (id) {
            // Check if exists first to decide between insert/update or use upsert if supported
            // For generic SQL, explicit check is safer across dialects
            const exists = await this.db(collection).where('id', id).first();

            if (exists) {
                await this.db(collection).where('id', id).update(cleanData);
                return id;
            } else {
                // If ID is provided but doesn't exist, insert it
                await this.db(collection).insert({ ...cleanData, id });
                return id;
            }
        } else {
            // Insert and return generated ID (or use UUID if generated by app)
            // Note: This assumes the DB generates IDs or they are part of data. 
            // If 'id' is not in data, we might need to handle it.
            // For consistency with other adapters, if 'id' is missing, we might let DB handle it 
            // but we need to return it.

            // Knex insert returns [id] for some dialects, but not all consistently.
            // Best practice for this library: Ensure ID is generated before save if possible, 
            // or rely on returning clause if supported.

            // For simplicity and broad compatibility, we'll assume data might contain an ID 
            // or we insert and try to retrieve.

            const [insertedId] = await this.db(collection).insert(cleanData).returning('id');

            // Fallback for dialects that don't support .returning() (like MySQL/SQLite sometimes)
            // If insertedId is object (Postgres returns {id: ...}), handle it.
            if (typeof insertedId === 'object' && insertedId !== null) {
                return (insertedId as any).id;
            }

            return insertedId?.toString() || '';
        }
    }

    async delete(collection: string, id: string): Promise<void> {
        await this.db(collection).where('id', id).delete();
    }

    async query<T = any>(collection: string, filters?: IQueryFilters): Promise<T[]> {
        let query = this.db(collection);

        if (filters) {
            Object.entries(filters).forEach(([key, value]) => {
                query = query.where(key, value);
            });
        }

        return await query.select('*');
    }

    async deleteMany(collection: string, filters: IQueryFilters): Promise<number> {
        let query = this.db(collection);

        if (filters) {
            Object.entries(filters).forEach(([key, value]) => {
                query = query.where(key, value);
            });
        }

        return await query.delete();
    }

    async updateMany(collection: string, filters: IQueryFilters, data: any): Promise<number> {
        let query = this.db(collection);

        if (filters) {
            Object.entries(filters).forEach(([key, value]) => {
                query = query.where(key, value);
            });
        }

        const cleanData = this.sanitizeData(data);
        return await query.update(cleanData);
    }

    private sanitizeData(data: any): any {
        // SQL databases generally don't like 'undefined'. Convert to null or remove.
        // Also stringify objects/arrays if they are stored in JSON columns? 
        // For now, simple undefined cleanup.
        if (data === undefined) return null;
        if (data === null) return null;

        if (Array.isArray(data)) {
            // Basic JSON serialization for arrays if DB supports it, or just return as is for Knex to handle
            return JSON.stringify(data);
        }

        if (typeof data === 'object' && !(data instanceof Date)) {
            const result: any = {};
            for (const key in data) {
                const value = this.sanitizeData(data[key]);
                if (value !== undefined) {
                    result[key] = value;
                }
            }
            return result;
        }

        return data;
    }
}
